# Plan: Add Verbose Logging to sfa_xsv_analyzer_v2.py

**Objective:** Diagnose why the `sfa_xsv_analyzer_v2.py` script is getting stuck in a loop, repeatedly requesting help for `xsv` subcommands.

**Strategy:** Enhance the script with detailed logging at key points in the interaction loop with the Language Model (LLM) to capture the conversation history and LLM responses. This will help identify why the LLM is not proceeding after receiving tool call results.

**Detailed Plan for Adding Verbosity:**

1.  **Identify Key Logging Points in `sfa_xsv_analyzer_v2.py`:**
    *   **Before each `litellm.completion` call** within the main interaction loop (currently around line 478):
        *   **What to log:** The entire `messages` list that is about to be sent to the LLM.
        *   **Why:** This will show the exact history and context the LLM is working with at each turn.
    *   **After each `litellm.completion` call** (currently after line 491 where `response_message` is obtained):
        *   **What to log:** The full `response_message` object (e.g., using `response_message.model_dump(exclude_none=True)`).
        *   **Why:** This will reveal the LLM's complete output, including any reasoning, content, and tool call requests.
    *   **When a tool call result is prepared** (currently around line 518, before appending the tool result to `messages`):
        *   **What to log:** The `tool_response_content` that was generated by `execute_get_xsv_subcommand_help`.
        *   **Why:** This confirms the exact information being fed back to the LLM after it requests help for a subcommand.

2.  **Logging Implementation Details (for the "Code" mode to implement):**
    *   Use `console.log()` for simple strings.
    *   For complex objects like the `messages` list or the `response_message` object, use `console.log(json.dumps(object_to_log, indent=2))` after importing `json`. This ensures the output is human-readable.
        *   Alternatively, `rich.print` (from `from rich import print as rprint`) can be used for pretty-printing Python objects directly.
    *   Wrap these logs with clear visual markers, for example:
        ```python
        # At the top of the script, ensure json is imported if not already:
        # import json

        # ... inside the loop ...
        console.log("[bold yellow] --- MESSAGES TO LLM --- [/bold yellow]")
        try:
            console.log(json.dumps(messages, indent=2, ensure_ascii=False)) # ensure_ascii=False for better unicode display
        except TypeError: # Handle potential non-serializable objects if any
            from rich import print as rprint
            rprint(messages)
        console.log("[bold yellow] ----------------------- [/bold yellow]")

        # ... after getting response ...
        console.log("[bold magenta] --- LLM RESPONSE MESSAGE --- [/bold magenta]")
        try:
            console.log(json.dumps(response_message.model_dump(exclude_none=True), indent=2, ensure_ascii=False))
        except TypeError:
            from rich import print as rprint
            rprint(response_message)
        console.log("[bold magenta] -------------------------- [/bold magenta]")

        # ... before appending tool result ...
        console.log("[bold green] --- TOOL RESPONSE CONTENT --- [/bold green]")
        console.log(tool_response_content)
        console.log("[bold green] --------------------------- [/bold green]")
        ```

**Mermaid Diagram of the Loop and Logging Points:**

```mermaid
graph TD
    A[Start run_xsv_analyzer_agent_v2] --> B{Loop for max_interaction_turns};
    B --> C[Prepare 'messages' list];
    C --> LOG1[LOG: Print 'messages' list];
    LOG1 --> D[Call litellm.completion];
    D --> E[Receive 'response_message'];
    E --> LOG2[LOG: Print 'response_message'];
    LOG2 --> F{Tool call requested?};
    F -- Yes --> G[Execute tool (e.g., get_xsv_subcommand_help)];
    G --> H[Prepare 'tool_response_content'];
    H --> LOG3[LOG: Print 'tool_response_content'];
    LOG3 --> I[Add tool_response to 'messages'];
    I --> B;
    F -- No --> J{Final command received?};
    J -- Yes --> K[Execute final xsv command];
    J -- No --> B;
    B -- Max turns reached or error --> L[Agent Halted/Error];
    K --> M[Synthesize Answer & Finish];
```

**Next Steps (after this plan is written):**
1.  Confirm the plan file has been written successfully.
2.  Request to switch to a "Code" mode to implement these logging changes in `sfa_xsv_analyzer_v2.py`.
3.  After implementation, the user will run the script again, and the new verbose output will be analyzed to understand the looping behavior and propose a definitive fix.